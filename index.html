<html lang="en">
	<head>
		<title>Animation Creator</title>
	</head>
	<body>
		<div style="position: absolute; left: calc(50vw - 300px); top: 0px;">
			<canvas id="canv" style="border: 1px solid" width="600" height="400"></canvas><br>
			<input id="background" type="color" style="height: 21px" value="#ffffff">
		</div>
		<script>
const back = document.getElementById("background"), canvas = document.getElementById("canv"), add = document.getElementById("add");
const context = canvas.getContext("2d");
back.oninput = function() {
	canvas.style.backgroundColor = back.value;
};

const animation = [[]];
let tool = "rectangle", startX = 0, startY = 0, midX = 0, midY = 0, endX = 0, endY = 0, isDown = false, currentSelection = null, currentScene = 0, canvasWidth = 600, canvasHeight = 400;

class Child {
	constructor(type, properties) {
		this.type = type;
		this.properties = properties;
	}
}

const typesOfChildren = {
	RECT: 0,
	CIRC: 1
}

function render() {
	context.clearRect(0, 0, canvasWidth, canvasHeight);
	const scene = animation[currentScene].sort((a, b) => a.properties.layer - b.properties.layer);
	if (scene.length === 0) return;
	for (const child of scene) {
		const props = child.properties;
		switch (child.type) {
			case typesOfChildren.RECT: {
				context.lineWidth = props.strokeWidth;
				if (!props.isStrokeTop && props.strokeWidth !== 0) {
					context.strokeStyle = props.strokeColor;
					context.strokeRect(props.x, props.y, props.width, props.height);
				}
				context.fillStyle = props.color;
				context.fillRect(props.x, props.y, props.width, props.height);
				if (props.isStrokeTop && props.strokeWidth !== 0) {
					context.strokeStyle = props.strokeColor;
					context.strokeRect(props.x, props.y, props.width, props.height);
				}
				break;
			}
			case typesOfChildren.CIRC: {
				context.lineWidth = props.strokeWidth;
				context.beginPath();
				context.fillStyle = props.color;
				context.arc(props.x, props.y, props.radius, 0, Math.PI * 2);
				if (props.strokeWidth !== 0 && !props.isStrokeTop) {
					context.strokeStyle = props.strokeColor;
					context.stroke();
				}
				context.fill();
				if (props.strokeWidth !== 0 && props.isStrokeTop) {
					context.strokeStyle = props.strokeColor;
					context.stroke();
				}
				break;
			}
		}
	}
}

canvas.onmousedown = function(event) {
	const bounds = canvas.getBoundingClientRect();
	const scene = animation[currentScene];
	startX = event.clientX - bounds.x;
	startY = event.clientY - bounds.y;
	isDown = true;
	switch (tool) {
		case "rectangle":
			currentSelection = (scene[scene.length] = new Child(typesOfChildren.RECT, {x: startX, y: startY, width: 0, height: 0, color: "rgba(0, 0, 0, 0.5)", strokeColor: "rgba(0, 0, 0, 0.5)", strokeWidth: 0, isStrokeTop: false, layer: scene.length}));
			break;
		case "circle":
			currentSelection = (scene[scene.length] = new Child(typesOfChildren.CIRC, {x: startX, y: startY, radius: 0, color: "rgba(0, 0, 0, 0.5)", strokeColor: "rgba(0, 0, 0, 0.5)", strokeWidth: 0, isStrokeTop: false, layer: scene.length}));
			break;
	}
}

canvas.onmousemove = function(event) {
	if (!isDown) return;
	const bounds = canvas.getBoundingClientRect();
	midX = event.clientX - bounds.x;
	midY = event.clientY - bounds.y;
	switch (tool) {
		case "rectangle":
			currentSelection.properties.width = midX - startX;
			currentSelection.properties.height = midY - startY;
			break;
		case "circle":
			currentSelection.properties.radius = Math.hypot(midX - startX, midY - startY);
			break;
	}
	render();
}

canvas.onmouseup = function(event) {
	const bounds = canvas.getBoundingClientRect();
	endX = event.clientX - bounds.x;
	endY = event.clientY - bounds.y;
	isDown = false;
	switch (tool) {
		case "rectangle":
			currentSelection.properties.width = endX - startX;
			currentSelection.properties.height = endY - startY;
			break;
		case "circle":
			currentSelection.properties.radius = Math.hypot(endX - startX, endY - startY);
			break;
	}
	currentSelection.properties.color = "rgba(0, 0, 0, 1)";
	render();
}
		</script>
	</body>
</html>
